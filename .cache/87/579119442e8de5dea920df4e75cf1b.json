{"id":"index.html","dependencies":[{"name":"_css_loader","parent":"/Users/andrew/Projects/canvas-fun/index.html","resolved":"/usr/local/lib/node_modules/parcel-bundler/src/builtins/css-loader.js"}],"generated":{"html":"<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>HTML5 Canvas</title>\n\t</head>\n\t<body>\n\t\t<h1 id=\"header\">Start Drawing!</h1>\n\t\t<canvas id=\"draw\"></canvas>\n\t\t<script>var canvas = document.querySelector('#draw');\nvar ctx = canvas.getContext('2d');\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\nctx.strokeStyle = '#BADA55';\nctx.lineJoin = 'round';\nctx.lineCap = 'round';\nctx.lineWidth = '100';\nctx.globalCompositeOperation = 'lighten';\nvar isDrawing = false;\nvar lastX = 0;\nvar lastY = 0;\nvar hue = 0;\nvar direction = true;\n\nfunction draw(e) {\n  // stop draw when the mouse is not clicked down\n  if (!isDrawing) return;\n  console.log(e);\n  ctx.strokeStyle = \"hsl(\".concat(hue, \",100%,50%)\");\n  ctx.beginPath();\n  ctx.moveTo(lastX, lastY);\n  ctx.lineTo(e.offsetX, e.offsetY);\n  ctx.stroke();\n  var _ref = [e.offsetX, e.offsetY];\n  lastX = _ref[0];\n  lastY = _ref[1];\n}\n\ncanvas.addEventListener('mousedown', function (e) {\n  isDrawing = true;\n  var _ref2 = [e.offsetX, e.offsetY];\n  lastX = _ref2[0];\n  lastY = _ref2[1];\n  hue++;\n});\ncanvas.addEventListener('mousemove', function (e) {\n  draw(e);\n  hue++;\n\n  if (hue >= 360) {\n    return hue = 0;\n  }\n\n  if (ctx.lineWidth >= 100 || ctx.lineWidth <= 1) {\n    direction = !direction;\n  }\n\n  if (direction) {\n    ctx.lineWidth++;\n  } else {\n    ctx.lineWidth--;\n  }\n});\ncanvas.addEventListener('mouseup', function () {\n  return isDrawing = false;\n});\ncanvas.addEventListener('mouseout', function () {\n  return isDrawing = false;\n}); // for touch events\n\ncanvas.addEventListener('touchstart', handleStart, false);\ncanvas.addEventListener('touchend', handleEnd, false);\ncanvas.addEventListener('touchcancel', handleCancel, false);\ncanvas.addEventListener('touchmove', handleMove, false); // touch tracker\n\nvar ongoingTouches = []; // touch handlers\n\nfunction handleStart(evt) {\n  evt.preventDefault();\n  console.log('touchstart.');\n  var touches = evt.changedTouches;\n\n  for (var i = 0; i < touches.length; i++) {\n    console.log('touchstart:' + i + '...');\n    ongoingTouches.push(copyTouch(touches[i]));\n    var color = colorForTouch(touches[i]);\n    ctx.beginPath();\n    ctx.fillStyle = \"hsl(\".concat(color, \",100%,50%)\");\n    console.log('touchstart:' + i + '.');\n  }\n}\n\nfunction handleMove(evt) {\n  evt.preventDefault();\n  var touches = evt.changedTouches;\n\n  for (var i = 0; i < touches.length; i++) {\n    var color = colorForTouch(touches[i]);\n    var idx = ongoingTouchIndexById(touches[i].identifier);\n\n    if (idx >= 0) {\n      console.log('continuing touch ' + idx);\n      ctx.beginPath();\n      console.log('ctx.moveTo(' + ongoingTouches[idx].pageX + ', ' + ongoingTouches[idx].pageY + ');');\n      ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);\n      console.log('ctx.lineTo(' + touches[i].pageX + ', ' + touches[i].pageY + ');');\n      ctx.lineTo(touches[i].pageX, touches[i].pageY);\n      ctx.strokeStyle = \"hsl(\".concat(color, \",100%,50%)\");\n      ctx.stroke();\n      hue++;\n\n      if (hue >= 360) {\n        return hue = 0;\n      }\n\n      if (ctx.lineWidth >= 100 || ctx.lineWidth <= 1) {\n        direction = !direction;\n      }\n\n      if (direction) {\n        ctx.lineWidth++;\n      } else {\n        ctx.lineWidth--;\n      }\n\n      ongoingTouches.splice(idx, 1, copyTouch(touches[i])); // swap in the new touch record\n\n      console.log('.');\n    } else {\n      console.log(\"can't figure out which touch to continue\");\n    }\n  }\n}\n\nfunction handleEnd(evt) {\n  evt.preventDefault();\n  var touches = evt.changedTouches;\n\n  for (var i = 0; i < touches.length; i++) {\n    var color = colorForTouch(touches[i]);\n    var idx = ongoingTouchIndexById(touches[i].identifier);\n\n    if (idx >= 0) {\n      ctx.beginPath();\n      ctx.fillStyle = \"hsl(\".concat(color, \",100%,50%)\");\n      ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);\n      ctx.lineTo(touches[i].pageX, touches[i].pageY);\n      ongoingTouches.splice(idx, 1); // remove it; we're done\n    } else {\n      console.log(\"can't figure out which touch to end\");\n    }\n  }\n}\n\nfunction handleCancel(evt) {\n  evt.preventDefault();\n  console.log('touchcancel.');\n  var touches = evt.changedTouches;\n\n  for (var i = 0; i < touches.length; i++) {\n    var idx = ongoingTouchIndexById(touches[i].identifier);\n    ongoingTouches.splice(idx, 1); // remove it; we're done\n  }\n}\n\nfunction colorForTouch(touch) {\n  hue++;\n  console.log('color for touch with identifier ' + touch.identifier + ' = ' + hue);\n  return hue;\n}\n\nfunction copyTouch(touch) {\n  return {\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY\n  };\n}\n\nfunction ongoingTouchIndexById(idToFind) {\n  for (var i = 0; i < ongoingTouches.length; i++) {\n    var id = ongoingTouches[i].identifier;\n\n    if (id == idToFind) {\n      return i;\n    }\n  }\n\n  return -1; // not found\n}</script>\n\n\t\t<style>html,\n\t\t\tbody {\n\t\t\t\tmargin: 0;\n\t\t\t}\n\t\t\t#header {\n\t\t\t\tcolor: #bada55;\n\t\t\t\tmargin-left: 40%;\n\t\t\t}\n\t\t\t#draw {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 400;\n\t\t\t}</style>\n\t</body>\n</html>\n"},"hash":"860702df298b7f452b1fd86c597fcbbe","cacheData":{"env":{}}}